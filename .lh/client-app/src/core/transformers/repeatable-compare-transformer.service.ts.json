{
    "sourceFile": "client-app/src/core/transformers/repeatable-compare-transformer.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1627517528674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1627517528674,
            "name": "Commit-0",
            "content": "import { Injectable } from '@angular/core';\r\nimport { DataCompareTransformer, DataCompareConfigurations } from '@core/transformers/data-compare-transformer.service';\r\nimport { RepeatableSeparation } from '@core/models/repeatable-separation.model';\r\nimport * as _ from 'lodash';\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\n\r\nexport class RepeatableCompareDataTransformer\r\n    implements DataCompareTransformer<any, any, RepeatableSeparation<any>>\r\n{\r\n    config: DataCompareConfigurations = {\r\n        added: true,\r\n        edited: true,\r\n        deleted: true,\r\n        attached: true,\r\n        detached: true,\r\n        baseAttr: 'id',\r\n        obligatoryAttr: []\r\n    };\r\n\r\n    baseAttr = 'id';\r\n\r\n    transform(updated: any[], source: any[], config: DataCompareConfigurations = this.getDefaultConfig()): RepeatableSeparation<any> {\r\n        const repeatableSeparation = {} as RepeatableSeparation<any>;\r\n        this.config = { ...this.config, ...config };\r\n        this.baseAttr = this.config.baseAttr;\r\n        if (this.config.added) {\r\n            repeatableSeparation.added = [];\r\n        }\r\n\r\n        if (this.config.edited) {\r\n            repeatableSeparation.edited = [];\r\n        }\r\n\r\n        if (this.config.deleted) {\r\n            repeatableSeparation.deleted = [];\r\n        }\r\n\r\n        source.forEach((item, i) => {\r\n            if (this.isDeleted(item, updated) === false && this.config.deleted) {\r\n                repeatableSeparation.deleted.push(item[this.baseAttr]);\r\n            }\r\n            const editedItemIndex: number = this.isEdited(item, updated);\r\n            if (editedItemIndex !== -1 && this.config.edited) {\r\n                const changedValues = this.getChangedValues(updated[editedItemIndex], source[i]);\r\n                if(!_.isEmpty(changedValues)) {\r\n                    repeatableSeparation.edited.push(changedValues);\r\n                }\r\n            }\r\n        });\r\n        if (this.config.added) {\r\n            repeatableSeparation.added = this.addedItems(updated, source);\r\n        }\r\n        return repeatableSeparation;\r\n    };\r\n\r\n\r\n    isDeleted(item: any, updatedList: any[]): boolean {\r\n        let find = false;\r\n        updatedList.forEach((e) => {\r\n            if (e[this.baseAttr] === item[this.baseAttr]) {\r\n                find = true;\r\n            }\r\n        });\r\n        return find;\r\n    }\r\n\r\n    isEdited(oldItem: any, updatedList: any[]): number {\r\n        let index = -1;\r\n        updatedList.forEach((newItem, i) => {\r\n            if (newItem[this.baseAttr] === oldItem[this.baseAttr]) {\r\n                Object.keys(oldItem).forEach((key: string) => {\r\n                    if (oldItem[key as keyof typeof oldItem] !== newItem[key as keyof typeof newItem]) {\r\n                        index = i;\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        return index;\r\n    }\r\n\r\n    addedItems(updatedList: any[], source: any[]) {\r\n        const added: any[] = [];\r\n        updatedList.forEach((item) => {\r\n            if (item[this.baseAttr] === null || this.isAdded(item, source)) {\r\n                added.push(item);\r\n            }\r\n        });\r\n        //Remove ids if exists in the final added value\r\n        added.forEach((item: any) => {\r\n            delete item?.id;\r\n        });\r\n        return added;\r\n    }\r\n\r\n    isAdded(element: any, source: any[]): boolean {\r\n        let isAdded = true;\r\n        source.forEach((item) => {\r\n            if (item[this.baseAttr] === element[this.baseAttr]) {\r\n                isAdded = false;\r\n            }\r\n        });\r\n        return isAdded;\r\n    }\r\n\r\n    getChangedValues(updatedItem: any, sourseItem: any): any {\r\n        let changedValues: any = {};\r\n        const obligatoryValues: any = {};\r\n        Object.keys(sourseItem).forEach((key) => {\r\n            if (!_.isEqual(sourseItem[key as keyof typeof sourseItem], updatedItem[key as keyof typeof updatedItem])) {\r\n                changedValues[key as keyof typeof changedValues] = updatedItem[key as keyof typeof updatedItem];\r\n            }\r\n            else {\r\n                if(key && this.config.obligatoryAttr.includes(key)) {\r\n                    obligatoryValues[key as keyof typeof changedValues] = updatedItem[key as keyof typeof updatedItem];\r\n                }\r\n            }\r\n        });\r\n        if(!_.isEmpty(changedValues)) {\r\n            changedValues[this.baseAttr] = updatedItem[this.baseAttr];\r\n            changedValues = (!_.isEmpty(obligatoryValues)? {...changedValues, ...obligatoryValues} : changedValues);\r\n        }\r\n        return changedValues;\r\n    }\r\n\r\n    getDefaultConfig(): DataCompareConfigurations {\r\n        return {\r\n            added: true,\r\n            edited: true,\r\n            deleted: true,\r\n            attached: true,\r\n            detached: true,\r\n            baseAttr: 'id',\r\n            obligatoryAttr: []\r\n        };\r\n    }\r\n}\r\n"
        }
    ]
}