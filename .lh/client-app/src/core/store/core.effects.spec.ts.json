{
    "sourceFile": "client-app/src/core/store/core.effects.spec.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1627517528384,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1627517528384,
            "name": "Commit-0",
            "content": "/*import { CoreEffects } from '@core/store/core.effects';\r\nimport { Observable, of } from 'rxjs';\r\nimport { Action } from '@ngrx/store';\r\nimport { AuthenticationService } from '@core/services/authentication.service';\r\nimport { configureTestSuite } from '@root/fakes/fakes.utils';\r\nimport { TestBed } from '@angular/core/testing';\r\nimport { FakesModule } from '@root/fakes/fakes.module';\r\nimport { provideMockActions } from '@ngrx/effects/testing';\r\nimport { stub, spy } from 'sinon';\r\nimport { coreActions } from '@core/store/core.actions';\r\nimport { hot, cold } from 'jasmine-marbles';\r\nimport { routerActions } from '@routing/store/router.actions';\r\nimport { ApplicationRoutes } from '@libs/shared/settings/common.settings';\r\nimport { UserClaims } from '@core/models/user-claims.model';\r\nimport { NotificationsService } from '@core/services/notifications.service';\r\nimport { HttpErrorResponse } from '@angular/common/http';\r\nimport { IdleService } from '@core/services/idle.service';\r\nimport { provideMockStore } from '@ngrx/store/testing';\r\nimport { Role } from '@core/models/role.enum';\r\n\r\n\r\ndescribe(CoreEffects.name, () => {\r\n  let actions$: Observable<Action>;\r\n  let effects: CoreEffects;\r\n  let authService: AuthenticationService;\r\n  let notificationsService: NotificationsService;\r\n  let idleService: IdleService;\r\n\r\n\r\n  configureTestSuite(() => {\r\n    TestBed.configureTestingModule({\r\n      imports: [\r\n        FakesModule,\r\n      ],\r\n      declarations: [],\r\n      providers: [\r\n        CoreEffects,\r\n        provideMockActions(() => actions$),\r\n        IdleService,\r\n        provideMockStore()\r\n      ]\r\n    });\r\n  });\r\n\r\n  beforeEach(() => {\r\n    effects = TestBed.inject(CoreEffects);\r\n    authService = TestBed.inject(AuthenticationService);\r\n    notificationsService = TestBed.inject(NotificationsService);\r\n    idleService = TestBed.inject(IdleService);\r\n  });\r\n\r\n  it('should call validateCallback then dispatch toggleAuthenticationStatus when validateOidcCallback action is received', () => {\r\n    const spyFn = stub(authService, 'validateCallback').callsFake(() => of(true));\r\n    const action = coreActions.validateOidcCallback();\r\n    actions$ = hot('--a-', { a: action });\r\n\r\n    const toggleAuthenticationStatus = coreActions.toggleAuthenticationStatus();\r\n    const expected = cold('--(b)', { b: toggleAuthenticationStatus });\r\n\r\n    expect(effects.validateOidcCallback$).toBeObservable(expected);\r\n    expect(spyFn.calledOnce).toBeTruthy();\r\n  });\r\n\r\n  it('should call login then dispatch go to autologin when initiateAuthentication action is received while user is not authenticated', () => {\r\n    const isAuthStub = stub(authService, 'isAuthenticated').callsFake(() => false);\r\n    const loginSpy = spy(authService, 'login');\r\n    const action = coreActions.initiateAuthentication();\r\n    actions$ = hot('--a-', { a: action });\r\n\r\n    const goToAutoLogin = routerActions.go({ path: [ApplicationRoutes.autoLogin] });\r\n    const expected = cold('--b-', { b: goToAutoLogin });\r\n\r\n    expect(effects.initiateAuthentication$).toBeObservable(expected);\r\n    expect(loginSpy.calledOnce).toBeTruthy();\r\n    loginSpy.restore();\r\n    isAuthStub.restore();\r\n  });\r\n\r\n  it('should dispatch toggleAuthenticationStatus when initiateAuthentication action is received while user is authenticated', () => {\r\n    const isAuthStub = stub(authService, 'isAuthenticated').callsFake(() => true);\r\n    const isRootStub = stub(authService, 'isRootRoute').callsFake(() => false);\r\n    const action = coreActions.initiateAuthentication();\r\n    actions$ = hot('--a-', { a: action });\r\n\r\n    const toggleAuthenticationStatus = coreActions.toggleAuthenticationStatus();\r\n    const expected = cold('--b-', { b: toggleAuthenticationStatus });\r\n\r\n    expect(effects.initiateAuthentication$).toBeObservable(expected);\r\n    isAuthStub.restore();\r\n    isRootStub.restore();\r\n  });\r\n\r\n  it('should dispatch toggleAuthenticationStatus when initiateAuthentication is received and user is authenticated', () => {\r\n    const isAuthStub = stub(authService, 'isAuthenticated').callsFake(() => true);\r\n    const action = coreActions.initiateAuthentication();\r\n    actions$ = hot('--a-', { a: action });\r\n\r\n\r\n    const toggleAuthenticationStatus = coreActions.toggleAuthenticationStatus();\r\n    const expected = cold('--(b)-', { b: toggleAuthenticationStatus });\r\n\r\n    expect(effects.initiateAuthentication$).toBeObservable(expected);\r\n    isAuthStub.restore();\r\n  });\r\n\r\n  it('should getUserClaims then dispatch fetchUserClaimsSuccess and redirect to customers if user role is SeniorOperator when toggleAuthenticationStatus is received', () => {\r\n    const fakeUserClaims = {\r\n      role: Role.groupManager\r\n    } as UserClaims;\r\n    const getUserClaimsStub = stub(authService, 'getUserClaims').callsFake(() => of(fakeUserClaims));\r\n    const action = coreActions.toggleAuthenticationStatus();\r\n    actions$ = hot('--a-', { a: action });\r\n\r\n    const goToCustomers = routerActions.go({ path: [ApplicationRoutes.venuesList] });\r\n    const logEvent = coreActions.setAppInsightsContext(fakeUserClaims);\r\n    const fetchUserClaimsSuccess = coreActions.fetchUserClaimsSuccess(fakeUserClaims);\r\n    const expected = cold('--(bcde)-', { b: fetchUserClaimsSuccess, c: goToCustomers, d: coreActions.scheduleIdleCheck(), e: logEvent });\r\n\r\n    expect(effects.getUserClaims$).toBeObservable(expected);\r\n    expect(getUserClaimsStub.calledOnce).toBeTrue();\r\n    getUserClaimsStub.restore();\r\n  });\r\n\r\n  it('should getUserClaims then dispatch fetchUserClaimsSuccess and scheduleIdleCheck if url is not root when toggleAuthenticationStatus is received', () => {\r\n    const fakeUserClaims = {\r\n      role: Role.groupManager\r\n    } as UserClaims;\r\n    const getUserClaimsStub = stub(authService, 'getUserClaims').callsFake(() => of(fakeUserClaims));\r\n    const iRootStub = stub(authService, 'isRootRoute').callsFake(() => false);\r\n    const action = coreActions.toggleAuthenticationStatus();\r\n    actions$ = hot('--a-', { a: action });\r\n\r\n    const fetchUserClaimsSuccess = coreActions.fetchUserClaimsSuccess(fakeUserClaims);\r\n    const logEvent = coreActions.setAppInsightsContext(fakeUserClaims);\r\n    const expected = cold('--(bcd)-', { b: fetchUserClaimsSuccess, c: coreActions.scheduleIdleCheck(), d: logEvent });\r\n\r\n    expect(effects.getUserClaims$).toBeObservable(expected);\r\n    expect(getUserClaimsStub.calledOnce).toBeTrue();\r\n    getUserClaimsStub.restore();\r\n    iRootStub.restore();\r\n  });\r\n\r\n  it('should logout when logout action is received', () => {\r\n    const logoutSpy = spy(authService, 'logout');\r\n    const actionMarble = { a: coreActions.logout() };\r\n    actions$ = hot('--a-', actionMarble);\r\n\r\n    expect(effects.logout$).toBeObservable(cold('--a-', actionMarble));\r\n    expect(logoutSpy.calledOnce).toBeTruthy();\r\n    logoutSpy.restore();\r\n  });\r\n\r\n  it('should call notificationsService when there is an error', () => {\r\n    const notificationsSpy = spy(notificationsService, 'openPopup');\r\n    const actionMarble = { a: coreActions.displayHttpError({ error: 'error' } as HttpErrorResponse) };\r\n    actions$ = hot('--a-', actionMarble);\r\n    expect(effects.displayHttpError$).toBeObservable(cold('--a-', actionMarble));\r\n    expect(notificationsSpy.callCount).toBe(1);\r\n    notificationsSpy.restore();\r\n  });\r\n\r\n  it('should call scheduleIdleCheck when idleCheck is false', () => {\r\n    const stubFn = stub(idleService, 'isIdle').callsFake(() => false);\r\n    const action = coreActions.idleCheck();\r\n    actions$ = hot('--a-', { a: action });\r\n\r\n    const expected = cold('--(bc)-', { b: idleService.scheduleIdleCheck(), c: authService.checkAuthentication() });\r\n    expect(effects.idleCheck$).toBeObservable(expected);\r\n    expect(stubFn.calledOnce).toBeTrue();\r\n    stubFn.restore();\r\n  });\r\n\r\n  it('should call displayIdleAlert when idleCheck is true', () => {\r\n    const stubFn = stub(idleService, 'isIdle').callsFake(() => true);\r\n\r\n    const action = coreActions.idleCheck();\r\n    actions$ = hot('--a-', { a: action });\r\n    const expectedIdleCheck = idleService.displayIdleAlert(() => idleService.scheduleIdleCheck(), () => authService.autoLogout());\r\n    const expected = cold('--(bc)-', { b: expectedIdleCheck, c: authService.checkAuthentication() });\r\n\r\n    expect(effects.idleCheck$).toBeObservable(expected);\r\n    expect(stubFn.calledOnce).toBeTrue();\r\n    stubFn.restore();\r\n  });\r\n});\r\n*/\r\n"
        }
    ]
}